## 图论

### 树
#### 重心

性质:

1.以树的重心为根时，所有子树的大小都不超过整棵树大小的一半，这个是充要条件（重心至多两个，并且相邻

2.树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。

#### 树链剖分
```c++
struct HLD {
    int n;
    std::vector<int> par, dep, top, son, siz;
    std::vector<std::vector<int>> G;

    HLD() {}
    HLD(int _n) {
        init(_n);
    }
    void init(int _n) {
        this->n = _n;
        par.resize(n + 1);
        dep.resize(n + 1);
        top.resize(n + 1);
        son.resize(n + 1);
        siz.resize(n + 1);
        G.assign(n, {});
    }

    void addEdge(int u, int v) {
        G[u].push_back(v);
    }

    void work(int root = 1) {
        dfs1(root, root);
        dfs2(root, root);
    }

    void dfs1(int u, int fa) {
        siz[u] = 1;
        for (auto v : G[u]) {
            if (v == fa) continue;
            par[v] = u;
            dep[v] = dep[u] + 1;
            dfs1(v, u);
            siz[u] += siz[v];
            if (siz[v] > siz[son[u]]) {
                son[u] = v;
            }
        }
    }

    void dfs2(int u, int topf) {
        top[u] = topf;
        if (son[u]) {
            dfs2(son[u], topf);
        }
        for (auto v : G[u]) {
            if (son[u] == v || par[u] == v) continue;
            dfs2(v, v);
        }
    }

    int lca(int x, int y) {
        while (top[x] != top[y]) {
            if (dep[top[x]] < dep[top[y]]) {
                std::swap(x, y);
            }
            // to do [dfn[top[x]] -> dfn[x]]
            x = par[top[x]];
        }
        if (dep[x] < dep[y]) {
            std::swap(x, y);
        }
        // to do [dfn[y] -> dfn[x]]
        return y;
    }

    int dist(int u, int v) {
        return dep[u] + dep[v] - 2 * dep[lca(u, v)];
    }
};
```

### 强连通分量

```c++
struct SCC {
    int n;                             // 节点数
    std::vector<std::vector<int>> adj; // 图的邻接表
    std::vector<int> stk;              // 栈，用于 Tarjan 算法
    std::vector<int> dfn, low, bel;    // dfn: 访问顺序, low: 最小可回溯 dfn, bel: 节点所属 SCC 编号
    int cur, cnt;                      // cur: 当前时间戳, cnt: SCC 编号计数

    SCC() {}
    SCC(int n) {
        init(n);
    }

    void init(int n) {
        this->n = n;
        adj.assign(n, {});
        dfn.assign(n, -1);
        low.resize(n);
        bel.assign(n, -1);
        stk.clear();
        cur = cnt = 0;
    }

    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }

    void dfs(int x) {
        dfn[x] = low[x] = cur++;
        stk.push_back(x);

        for (auto y : adj[x]) {
            if (dfn[y] == -1) {
                dfs(y);
                low[x] = std::min(low[x], low[y]);
            } else if (bel[y] == -1) {
                low[x] = std::min(low[x], dfn[y]);
            }
        }

        if (dfn[x] == low[x]) {
            int y;
            do {
                y = stk.back();
                bel[y] = cnt;
                stk.pop_back();
            } while (y != x);
            cnt++;
        }
    }

    const std::vector<int>& work() {
        for (int i = 0; i < n; i++) {
            if (dfn[i] == -1) {
                dfs(i);
            }
        }
        return bel;
    }
};
```

### 点双

```c++
struct VDcc {
    int n, stamp;
    std::vector<int> dfn, low, stk, cut;
    std::vector<std::vector<int>> adj, vDc;

    VDcc() {}
    VDcc(int n) {
        init(n);
    }

    void init(int n) {
        this->n = n;
        stamp = -1;
        dfn.assign(n, -1);
        low.assign(n, -1);
        cut.assign(n, 0);
        adj.assign(n, {});

        stk.clear();
        vDc.clear();
    }

    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }

    void tarjan(int u, int anc) {
        dfn[u] = low[u] = ++stamp;
        if (adj[u].size() == 0) {
            vDc.push_back({ u });
            return;
        }
        stk.push_back(u);
        int child = 0;
        for (auto v : adj[u]) {
            if (dfn[v] == -1) {
                child++;
                tarjan(v, anc);
                low[u] = std::min(low[u], low[v]);
                if (low[v] >= dfn[u]) {
                    if (u != anc) {
                        cut[u] = 1;
                    }
                    std::vector<int> vc;
                    int tmp;
                    do {
                        tmp = stk.back();
                        stk.pop_back();
                        vc.push_back(tmp);
                    } while (v != tmp);
                    vc.push_back(u);
                    vDc.push_back(vc);
                }
            } else {
                low[u] = std::min(low[u], dfn[v]);
            }
        }
        if (child >= 2 && u == anc) cut[u] = 1;
    }

    const std::vector<std::vector<int>>& work() {
        for (int i = 0; i < n; i++) {
            if (dfn[i] == -1) {
                tarjan(i, i);
            }
        }
        return vDc;
    }
};
```

### 边双

```c++
struct EDcc {
    int n, m, idx, stamp;
    std::vector<int> e, ne, h;
    std::vector<int> dfn, low, stk;
    std::vector<char> bridge; // 判断边是不是桥
    std::vector<std::vector<int>> eDc;

    EDcc() {}
    EDcc(int n, int m) {
        init(n, m);
    }

    void init(int n, int m) {
        this->n = n;
        this->m = m;
        idx = -1;
        stamp = -1;
        h.assign(n, -1);
        dfn.assign(n, -1);
        low.assign(n, -1);

        ne.assign(m * 2, -1);
        e.assign(m * 2, -1);
        bridge.assign(m * 2, -1);

        stk.clear();
        eDc.clear();
    }

    void addEdge(int u, int v) {
        e[++idx] = v;
        ne[idx] = h[u];
        h[u] = ++idx;
    }

    void tarjan(int u, int lst) {
        dfn[u] = low[u] = ++stamp;
        stk.push_back(u);

        for (int i = h[u]; i != -1; i = ne[i]) {
            int v = e[i];
            if ((i ^ 1) == lst) continue;
            if (dfn[v] == -1) {
                tarjan(v, i);
                low[u] = std::min(low[u], low[v]);
                if (low[v] > dfn[u]) {
                    bridge[i] = bridge[i ^ 1] = 1;
                }
            } else {
                low[u] = std::min(low[u], dfn[v]);
            }
        }
        if (dfn[u] == low[u]) {
            std::vector<int> vc;
            int tmp;
            do {
                tmp = stk.back();
                stk.pop_back();
                vc.push_back(tmp);
            } while (tmp != u);
            eDc.push_back(vc);
        }
    }

    void work() {
        for (int i = 0; i < n; i++) {
            if (dfn[i] == -1) {
                tarjan(i, -1);
            }
        }
    }
};
```
### 网络流

最大流

```c++
struct MaxFlow {
    int n, m, idx;
    std::vector<int> e, ne, h;
    std::vector<int> cur, dep;
    std::vector<LL> val;

    MaxFlow(int _n, int _m) {
        init(_n, _m);
    }

    void init(int _n, int _m) {
        this->n = _n;
        this->m = _m;
        idx = -1;
        e.resize(m << 1);
        ne.resize(m << 1);
        h.resize(n, -1);
        val.resize(m << 1);
        cur.resize(n);
        dep.resize(n);
    }

    void addEdge(int from, int to, LL w) {
        e[++idx] = to;
        val[idx] = w;
        ne[idx] = h[from];
        h[from] = idx;
    }

    bool bfs(int st, int ed) {
        dep.assign(n, -1);
        std::queue<int> q;
        q.push(st);
        dep[st] = 0;
        while (!q.empty()) {
            auto u = q.front();
            q.pop();
            cur[u] = h[u];
            for (int i = h[u]; ~i; i = ne[i]) {
                int v = e[i];
                if (dep[v] == -1 && val[i]) {
                    dep[v] = dep[u] + 1;
                    if (v == ed) return true;
                    q.push(v);
                }
            }
        }
        return false;
    }

    LL dfs(int ed, int u, LL limit) {
        if (u == ed) return limit;
        LL flow = 0;
        for (int i = cur[u]; ~i; i = ne[i]) {
            cur[u] = i;
            int v = e[i];
            if (dep[v] == dep[u] + 1 && val[i]) {
                LL find_flow = dfs(ed, v, std::min(limit - flow, val[i]));
                val[i] -= find_flow;
                val[i ^ 1] += find_flow;
                flow += find_flow;
                if (flow == limit)
                    return flow;
            }
        }
        return flow;
    }

    LL work(int s, int t) {
        LL maxflow = 0;
        while (bfs(s, t)) {
            maxflow += dfs(t, s, std::numeric_limits<LL>::max() / 2);
            maxflow = std::min(maxflow, std::numeric_limits<LL>::max() / 2);
        }
        return maxflow;
    }
};
```
最小费用最大流，SPFA控制费用
```c++
struct MCF {
    int n, m, idx;
    std::vector<int> h, ne, e;
    std::vector<int> pre, flow;
    std::vector<int> dis, cap, cost;

    MCF(int _n, int _m): idx(-1) {
        init(_n, _m);
    }

    void init(int _n, int _m) {
        this->n = _n, this->m = _m;
        h.resize(n, -1);
        ne.resize(m << 1);
        e.resize(m << 1);

        pre.resize(m << 1);
        flow.resize(n);

        dis.resize(n);
        cap.resize(m << 1);
        cost.resize(m << 1);
    }

    void addEdge(int u, int v, int vol, int w) {
        add(u, v, vol, w);
        add(v, u, 0, -w);
    }

    bool spfa(int st, int ed) {
        // shortest path
        dis.assign(n, 0x3f3f3f3f);
        flow.assign(n, 0x3f3f3f3f);
        std::vector<char> vis(n);
        std::queue<int> q;
        q.push(st);
        vis[st] = 1, dis[st] = 0;
        while (!q.empty()) {
            auto u = q.front();
            q.pop();
            vis[u] = 0;
            for (int i = h[u]; ~i; i = ne[i]) {
                int v = e[i];
                if (!cap[i]) continue;
                if (dis[v] > dis[u] + cost[i]) {
                    dis[v] = dis[u] + cost[i];
                    flow[v] = std::min(flow[u], cap[i]);
                    pre[v] = i;
                    if (!vis[v]) {
                        q.push(v);
                        vis[v] = 1;
                    }
                }
            }
        }
        return dis[ed] != 0x3f3f3f3f;
    }

    void update(int st, int ed) {
        int u = ed;
        while (u != st) {
            int i = pre[u];
            cap[i] -= flow[ed];
            cap[i ^ 1] += flow[ed];
            u = e[i ^ 1];
        }
    }

    std::pair<int, int> work(int st, int ed) {
        int maxflow = 0, res_cost = 0;
        while (spfa(st, ed)) {
            update(st, ed);
            maxflow += flow[ed];
            res_cost += flow[ed] * dis[ed];
        }
        return { maxflow, res_cost };
    }

private:
    void add(int a, int b, int vol, int w) {
        e[++idx] = b;
        cap[idx] = vol;
        cost[idx] = w;
        ne[idx] = h[a];
        h[a] = idx;
    }
};
```