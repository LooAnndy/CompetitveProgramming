## 数学
常见数据范围

![约数个数](.\约数个数.png)

### 逆元

对任意模数p的逆元递推

```c++
std::vector<i64> inv(p);
inv[1] = 1;
for (i64 i = 2; i < p; i++) {
    inv[i] = (p - (p / i) * 1LL * inv[p % i] % p) % p;
}
```
### 组合数的恒等式和性质


### exgcd
```c++
int exgcd(int a, int b, int& x, int& y) {
    if (!b) {
        x = 1;
        y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
```

### 线性筛和一些数论函数
$minp_{x}$代表x的最小质因数

$mu_{x}$是$\mu(x)$莫比乌斯函数

$
\mu(n) = 
\begin{cases} 
1, & \text{若 } n = 1, \\
0, & \text{若 } n \text{ 含有平方因子（即存在质数 } p \text{ 使得 } p^2 \mid n\text{）}, \\
(-1)^k, & \text{若 } n \text{ 是 } k \text{ 个不同质数的乘积}.
\end{cases}
$

$phi_{n}$是$\phi(n)$表示的是小于等于 
n 并且 n 互质的数的个数

一些积性函数都可以在线性筛中计算
```c++
struct Prime {
    std::vector<int> primes, minp, mu, phi;

    Prime(int n) {
        sieve(n);
    }

    void sieve(int n) {
        minp.assign(n + 1, 0);
        mu.assign(n + 1, 0);
        phi.assign(n + 1, 0);
        primes.clear();

        mu[1] = phi[1] = 1;
        for (int i = 2; i <= n; i++) {
            if (minp[i] == 0) {
                primes.push_back(i);
                minp[i] = i;
                mu[i] = -1;
                phi[i] = i - 1;
            }

            for (auto p : primes) {
                if (i * p > n) {
                    break;
                }
                minp[i * p] = p;
                if (i % p == 0) {
                    mu[i] = 0;
                    phi[i * p] = phi[i] * p;
                    break;
                }
                mu[i * p] = -mu[i];
                phi[i * p] = phi[i] * (p - 1);
            }
        }
    }
};
```

#### 二项式反演
第一种形式$g(n)表示至多n种方案的数量，f(n)表示恰好n种方案的数量$ $$g(n)=\sum_{i=0}^{n}{n \choose i}f(i)\Leftrightarrow  f(n) = \sum_{i=0}^{n}(-1)^{n-i}{n \choose i}g(i)$$ </br>
第二种形式$g(k)表示至少k种方案的数量，f(k)表示恰好k种方案的数量$ $$g(k)=\sum_{i=k}^{n}{i \choose k}f(i)\Leftrightarrow  f(k) = \sum_{i=k}^{n}(-1)^{i-k}{i \choose k}g(i)$$</br>

#### 欧拉函数反演
$$n=\sum_{d|n}\phi(d)$$
令$n=gcd(a,b)$，有

$$gcd(a,b)=\sum_{d|gcd(a,b)}\phi(d)=\sum_{d}[d|a][d|b]\phi(d)$$

那么

$$
\sum_{i=1}^{n} \gcd(i, n) = \sum_{d} \sum_{i=1}^{n} 
[d|i] [d|n]
 \varphi(d) = \sum_{d} \left\lfloor \frac{n}{d} \right\rfloor [d|n] \varphi(d) = \sum_{d|n} \left\lfloor \frac{n}{d} \right\rfloor \varphi(d).
$$

#### 莫比乌斯反演
对于数论函数$g(n),f(n)$，如果有$$f(n)=\sum_{d|n}g(d)$$那么$$g(n)=\sum_{d|n}\mu(d)f(\frac{n}{d})$$

### 线性基(异或线性基)

```c++
struct LinearBasis {
    static constexpr int K = 60;
    array<ull, K> b;

    LinearBasis() {
        b.fill(0);
    }

    bool insert(ull x) {
        for (int i = K - 1; i >= 0; i--) {
            if (!(x >> i & 1)) continue;
            if (!b[i]) {
                b[i] = x;
                return 1;
            }
            x ^= b[i];
        }
        return 0;
    }

    ull ask(ull x = 0) {
        for (int i = K - 1; i >= 0; i--) {
            if ((x ^ b[i]) > x) {
                x ^= b[i];
            }
        }
        return x;
    }
};
```

### 高斯消元

```c++
int row = 1;
for (int col = 63; col >= 0 && row <= n; col--) {
    for (int i = row; i <= n; i++) {
        if (a[i] >> col & 1) {
            std::swap(a[row], a[i]);
            break;
        }
    }
    if (!(a[row] >> col & 1)) continue;
    for (int i = 1; i <= n; i++) {
        if (i == row) continue;
        if (a[i] >> col & 1) {
            a[i] ^= a[row];
        }
    }
    row++;
}
--row;
```
#### 查询k小值
高斯消元后能保证每一个位数上的1都是独特的，所以说查询第k个元素的时候直接
对k进行二进制分解对于每一位上的1，去找线性基上唯一的1对应的数异或即可。

注意对0的特判(没有0应该查询x-1)(线性基相比于原来的大小变小就是可以有0)